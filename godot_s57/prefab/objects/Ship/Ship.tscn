[gd_scene load_steps=5 format=3 uid="uid://jywn1e0tmbbu"]

[ext_resource type="PackedScene" uid="uid://chlm3a147a37f" path="res://prefab/objects/Ship/Simple Battleship.glb" id="1_0pr7t"]
[ext_resource type="Script" uid="uid://depyr4nvddnc" path="res://Scripts/WORLD_sc/SimpleBuoyancy.gd" id="1_h5k0y"]

[sub_resource type="BoxShape3D" id="BoxShape3D_h5k0y"]
size = Vector3(9.01664, 2.54111, 2.23563)

[sub_resource type="GDScript" id="GDScript_xyd1p"]
resource_name = "RosMan_2"
script/source = "extends Node3D

# --- AYARLAR ---
@export var offline_test_mode: bool = false
@export var socket_url: String = \"\" 
@export var publish_rate: float = 10.0

# --- LIDAR VE FRAME AYARLARI ---
const SCAN_FRAME_ID = \"base_scan\"
const ODOM_FRAME_ID = \"odom\"
const ROBOT_BASE_FRAME = \"base_link\"

# Lidar AÃ§Ä±larÄ± (-90 sol, +90 saÄŸ)
const ANGLE_MIN = -PI/2
const ANGLE_MAX = PI/2
const RANGE_MIN = 0.5

@export_group(\"Navigasyon Lidar\")
@export var nav_lidar_node: Node3D 
@export var nav_rays: int = 72 
@export var nav_range: float = 50.0 
@export var show_nav_debug: bool = true 

# --- SABÄ°TLER ---
const ODOM_COVARIANCE_ARRAY = [
	1.0e-05, 0.0, 0.0, 0.0, 0.0, 0.0,
	0.0, 1.0e-05, 0.0, 0.0, 0.0, 0.0, 
	0.0, 0.0, 1000000000000.0, 0.0, 0.0, 0.0,
	0.0, 0.0, 0.0, 1000000000000.0, 0.0, 0.0,
	0.0, 0.0, 0.0, 0.0, 1000000000000.0, 0.0,
	0.0, 0.0, 0.0, 0.0, 0.0, 0.001
]

var socket = WebSocketPeer.new()
var nav_raycasts: Array[RayCast3D] = []
var last_publish_time = 0.0
var is_connected = false

# Parent artÄ±k SimpleBuoyancy scriptine sahip RigidBody
@onready var real_ship = get_parent()

func _ready():
	# --- 1. LIDAR KURULUMU ---
	if nav_lidar_node:
		_setup_lidar(nav_lidar_node, nav_rays, nav_range, 180.0, nav_raycasts, Color.RED)
	
	# --- 2. BAÄžLANTI ---
	if offline_test_mode:
		print(\"ðŸ› ï¸ OFFLINE MOD: Soket kapalÄ±.\")
	else:
		if socket_url == \"\":
			print(\"âš ï¸ HATA: Socket URL boÅŸ! Inspector'dan IP girin.\")
			return
		print(\"ðŸ“¡ RADAR: BaÄŸlantÄ± kuruluyor... \", socket_url)
		socket.connect_to_url(socket_url)

func _setup_lidar(parent_node, count, dist, fov_angle, array_ref, color):
	for i in range(count):
		var ray = RayCast3D.new()
		parent_node.add_child(ray)
		var angle = 0.0
		if fov_angle >= 360: angle = i * (TAU / count)
		else:
			if count > 1: angle = deg_to_rad(-fov_angle/2 + (i * fov_angle / (count-1)))
			else: angle = 0.0
			
		if parent_node == nav_lidar_node:
			ray.target_position = Vector3(dist, 0, 0).rotated(Vector3.UP, angle + PI)
		else:
			ray.target_position = Vector3(0, -dist, 0).rotated(Vector3.RIGHT, angle)
			
		ray.enabled = true
		ray.debug_shape_custom_color = color
		ray.debug_shape_thickness = 2
		array_ref.append(ray)

# --- ZAMAN VE DÃ–NÃœÅžÃœM ---

func get_ros_timestamp() -> Dictionary:
	var current_unix_time = Time.get_unix_time_from_system()
	var seconds = int(floor(current_unix_time))
	var nanoseconds = int((current_unix_time - seconds) * 1_000_000_000)
	return { \"sec\": seconds, \"nanosec\": nanoseconds }

func position_godot_to_ros(pos_godot: Vector3) -> Dictionary:
	return { \"x\": -pos_godot.z, \"y\": -pos_godot.x, \"z\": pos_godot.y }

func orientation_godot_to_ros(basis_godot: Basis) -> Dictionary:
	var q = basis_godot.get_rotation_quaternion()
	return { \"x\": q.z, \"y\": q.x, \"z\": -q.y, \"w\": q.w }

func create_twist_message(ship_node):
	var lin = ship_node.linear_velocity
	var ang = ship_node.angular_velocity
	return {
		\"linear\": { \"x\": -lin.z, \"y\": -lin.x, \"z\": lin.y },
		\"angular\": { \"x\": -ang.z, \"y\": -ang.x, \"z\": ang.y }
	}

# --- HEDEF GÃ–NDERME (Point Tipi - Ä°stenilen Format) ---

func publish_goal(godot_goal_pos: Vector3):
	var ros_pos = position_godot_to_ros(godot_goal_pos)
	
	# Sadece X, Y, Z iÃ§eren basit mesaj
	var point_msg = {
		\"x\": ros_pos.x,
		\"y\": ros_pos.y,
		\"z\": 0.0
	}
	
	if not offline_test_mode:
		print(\"ðŸŽ¯ YENÄ° HEDEF GÄ°DÄ°YOR (Point): \", point_msg)
		# Tipi advertise kÄ±smÄ±nda belirttik, burada sadece publish ve msg yolluyoruz
		_send_ros_msg(\"publish\", \"/goal_pose\", point_msg)
	else:
		print(\"ðŸ› ï¸ OFFLINE MOD: Hedef -> \", point_msg)

# --- MESAJ OLUÅžTURUCULAR ---

func create_tf_message(timestamp, ship_node) -> Dictionary:
	var global_t = ship_node.global_transform
	var pos_ros = position_godot_to_ros(global_t.origin)
	var quat_ros = orientation_godot_to_ros(global_t.basis)
	
	var transform_stamped = {
		\"header\": { \"stamp\": timestamp, \"frame_id\": ODOM_FRAME_ID },
		\"child_frame_id\": ROBOT_BASE_FRAME,
		\"transform\": { \"translation\": pos_ros, \"rotation\": quat_ros }
	}
	return { \"transforms\": [transform_stamped] }

func create_odom_message(timestamp, ship_node) -> Dictionary:
	var global_t = ship_node.global_transform
	var pos_ros = position_godot_to_ros(global_t.origin)
	var quat_ros = orientation_godot_to_ros(global_t.basis)
	var twist_ros = create_twist_message(ship_node)
	
	return {
		\"header\": { \"stamp\": timestamp, \"frame_id\": ODOM_FRAME_ID },
		\"child_frame_id\": ROBOT_BASE_FRAME,
		\"pose\": {
			\"pose\": { \"position\": pos_ros, \"orientation\": quat_ros },
			\"covariance\": ODOM_COVARIANCE_ARRAY
		},
		\"twist\": { \"twist\": twist_ros, \"covariance\": ODOM_COVARIANCE_ARRAY }
	}

func create_scan_message(timestamp, raycast_array: Array) -> Dictionary:
	var ranges = []
	for ray in raycast_array:
		ray.force_raycast_update()
		var distance = nav_range 
		if ray.is_colliding():
			distance = ray.get_collision_point().distance_to(ray.global_transform.origin)
			if distance > nav_range: distance = nav_range
			elif distance < RANGE_MIN: distance = RANGE_MIN
		ranges.append(distance)
				
	return {
		\"header\": { \"stamp\": timestamp, \"frame_id\": SCAN_FRAME_ID },
		\"angle_min\": ANGLE_MIN, \"angle_max\": ANGLE_MAX,
		\"angle_increment\": PI / float(nav_rays),
		\"time_increment\": 0.0, \"scan_time\": 0.0,
		\"range_min\": RANGE_MIN, \"range_max\": nav_range,
		\"ranges\": ranges, \"intensities\": []
	}

# --- ANA DÃ–NGÃœ ---

func _process(delta):
	if offline_test_mode: return
	socket.poll()
	var state = socket.get_ready_state()
	
	if state == WebSocketPeer.STATE_OPEN:
		if not is_connected: _on_connection_success()
		while socket.get_available_packet_count():
			var packet = socket.get_packet().get_string_from_utf8()
			_handle_incoming(packet)
		
		last_publish_time += delta
		if last_publish_time >= (1.0 / publish_rate):
			_publish_data()
			last_publish_time = 0.0
	elif state == WebSocketPeer.STATE_CLOSED:
		is_connected = false

func _on_connection_success():
	print(\"âœ… BAÄžLANTI BAÅžARILI!\")
	is_connected = true
	
	socket.send_text(JSON.stringify({\"op\": \"advertise\", \"topic\": \"/odom\", \"type\": \"nav_msgs/msg/Odometry\"}))
	socket.send_text(JSON.stringify({\"op\": \"advertise\", \"topic\": \"/scan\", \"type\": \"sensor_msgs/msg/LaserScan\"}))
	socket.send_text(JSON.stringify({\"op\": \"advertise\", \"topic\": \"/tf\", \"type\": \"tf2_msgs/msg/TFMessage\"}))
	
	# --- BURASI GÃœNCELLENDÄ°: geometry_msgs/msg/Point ---
	socket.send_text(JSON.stringify({\"op\": \"advertise\", \"topic\": \"/goal_pose\", \"type\": \"geometry_msgs/msg/Point\"}))
	
	socket.send_text(JSON.stringify({\"op\": \"subscribe\", \"topic\": \"/cmd_vel\", \"type\": \"geometry_msgs/msg/Twist\"}))

func _publish_data():
	var timestamp = get_ros_timestamp()
	if real_ship:
		_send_ros_msg(\"publish\", \"/odom\", create_odom_message(timestamp, real_ship))
		_send_ros_msg(\"publish\", \"/tf\", create_tf_message(timestamp, real_ship))
	_send_ros_msg(\"publish\", \"/scan\", create_scan_message(timestamp, nav_raycasts))

func _send_ros_msg(op, topic, msg):
	# publish yaparken type yazmaya gerek yok, advertise'da belirttik.
	# Rosbridge protokolÃ¼: { \"op\": \"publish\", \"topic\": \"...\", \"msg\": ... }
	socket.send_text(JSON.stringify({ \"op\": op, \"topic\": topic, \"msg\": msg }))

func _handle_incoming(json_str):
	var json = JSON.new()
	if json.parse(json_str) == OK:
		var data = json.get_data()
		if data.has(\"topic\") and data[\"topic\"] == \"/cmd_vel\":
			var msg = data[\"msg\"]
			print(\"ðŸ“© EMÄ°R: L:\", msg[\"linear\"][\"x\"], \" A:\", msg[\"angular\"][\"z\"])
			
			if real_ship:
				if \"ros_throttle\" in real_ship:
					real_ship.ros_throttle = clamp(msg[\"linear\"][\"x\"], -1.0, 1.0)
				if \"ros_steering\" in real_ship:
					real_ship.ros_steering = clamp(msg[\"angular\"][\"z\"], -1.0, 1.0)
"

[node name="Ship" type="RigidBody3D"]
transform = Transform3D(-4.37114e-08, 0, -1, 0, 1, 0, 1, 0, -4.37114e-08, 0, 0, 0)
mass = 50.0
script = ExtResource("1_h5k0y")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.201505, 0.731617, -0.0677704)
shape = SubResource("BoxShape3D_h5k0y")
debug_color = Color(0.239846, 0.589756, 0, 0.419608)

[node name="Simple Battleship" parent="." instance=ExtResource("1_0pr7t")]
transform = Transform3D(3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 1.8, 0)

[node name="ChaseCamera" type="Camera3D" parent="."]
transform = Transform3D(-4.37114e-08, -0.707107, 0.707107, 0, 0.707107, 0.707107, -1, 3.09086e-08, -3.09086e-08, 3.75056, 8.76067, -0.118086)
fov = 100.0
near = 0.1

[node name="RosManager" type="Node3D" parent="." node_paths=PackedStringArray("nav_lidar_node")]
script = SubResource("GDScript_xyd1p")
socket_url = "ws://172.20.10.3:9090"
nav_lidar_node = NodePath("LidarHorizontal")
nav_rays = 36

[node name="LidarDepth" type="Node3D" parent="RosManager"]
transform = Transform3D(-4.37114e-08, -0.707107, 0.707107, 0, 0.707107, 0.707107, -1, 3.09086e-08, -3.09086e-08, 0, -0.162156, 0)

[node name="LidarHorizontal" type="Node3D" parent="RosManager"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -4.60467, 2.22947, 2.01276e-07)
